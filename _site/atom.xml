<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title></title>
 <link href="http://wanghongjun2014.github.io/atom.xml" rel="self"/>
 <link href="http://wanghongjun2014.github.io"/>
 <updated>2017-04-23T02:42:36-07:00</updated>
 <author>
   <name>王洪军</name>
   <email>wanghongjun2014#163.com</email>
 </author>

 
 <entry>
   <title>汉诺塔算法</title>
   <link href="http://wanghongjun2014.github.io/posts/hannuota-suanfa.html"/>
   <updated>2017-04-23T00:00:00-07:00</updated>
   <id>/posts/hannuota-suanfa</id>
   <content type="html">&lt;p&gt;下午研究下汉诺塔算法, 挺有意思的, 大体示意图如下:
&lt;img src=&quot;/assets/hannuota.png&quot; alt=&quot;hannuota&quot; title=&quot;汉诺塔&quot; /&gt;&lt;/p&gt;

&lt;p&gt;说明:A.B.C分别表示三根柱子, 1，2，3分别表示三个圆盘, 并且数字越大表示圆盘越大, 现在我们需要将A上的全部圆盘移动到C上&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;只有一个圆盘1的情况, 直接从&lt;strong&gt;A-&amp;gt;C&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;有2个圆盘1 2, 则 A-&amp;gt;B  &lt;strong&gt;A-&amp;gt;C&lt;/strong&gt; B-&amp;gt;C&lt;/li&gt;
  &lt;li&gt;有3个圆盘1 2 3的情况下, 总共需要7步。 A-&amp;gt;C A-&amp;gt;B C-&amp;gt;B &lt;strong&gt;A-&amp;gt;C&lt;/strong&gt; B-&amp;gt;A B-&amp;gt;C A-&amp;gt;C&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;分析过程, 不管有几个盘子, 最重要的就是&lt;strong&gt;A-&amp;gt;C&lt;/strong&gt;(步骤中加粗)这一步, 也就是把数字最大的盘子移动到C柱子上, 以3个盘子为例, 在A-&amp;gt;C步骤的上面表示把1号和2号盘子
从起点A移动到终点B, 下面表示把1号盘子和2号盘子从起点B移动到终点C, 所以可以用一种递归的思想表示这个过程&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;假如函数原型是move(n, A, B, C)
#上面的部分: n-1个圆盘从A-&amp;gt;B
move(n-1, A, C, B)
#中间部分, 号码最大的盘子从A-&amp;gt;C
move(1, A, B, C)
#下面部分: n-1个圆盘从B-&amp;gt;C
move(n-1, B, A, C)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;算法代码为&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/usr/local/bin/python3
# _*_ coding: utf-8 _*_

def move(n, a, b, c):
    if n == 1:
        print(a, '-&amp;gt;', c)
    else:
        move(n-1, a, c, b)
        move(1, a, b, c)
        move(n-1, b, a, c)

count = input(&quot;请输入要移动到圆盘个数: &quot;)
move(int(count), 'A', 'B', 'C')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;效果为:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/hannuota-result.png&quot; alt=&quot;result&quot; title=&quot;结果&quot; /&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>acsii-unicode-utf8编码的来源以及关系</title>
   <link href="http://wanghongjun2014.github.io/posts/unicode-utf8.html"/>
   <updated>2017-04-22T00:00:00-07:00</updated>
   <id>/posts/unicode-utf8</id>
   <content type="html">&lt;p&gt;周末的时候细下心来查询整理下了一下字符串编码的来源以及各种格式之间的关系,以下纯属自己的理解思路,如有误,欢迎指出:&lt;/p&gt;

&lt;hr /&gt;

&lt;ol&gt;
  &lt;li&gt;关于ascii码
    &lt;pre&gt;&lt;code&gt;最早的时候计算机是由老外发明的, 他们只把127个字符编码到计算机中, 其中包括大小写字母和一些特殊符号, 这个
编码表被称为ASCII编码,比如大写字母A的编码是65,小写字母z的编码是122, 所以针对ascii编码而言, 1个字节(8
个byte)足以了, 因为1个字节最大二进制表示为 11111111, 十进制位256
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;关于中文编码
    &lt;pre&gt;&lt;code&gt;第一条说的英文, 对于中文而言, 1个字节明显不够, 刚刚百度查了下, 中国的汉字大约有10W多个, 至少2个字节吧,
2个字节最大为 1111111111111111十进制数位 65535 ,所以中国就出现了GBK系列的编码, 但是如果每个国家都制定自己的一套编码那岂不是乱套了吗, 所以为了统一unicode编码就出现了
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;unicode编码
    &lt;pre&gt;&lt;code&gt;unicode把所有的编码都统一到一套编码里, 它的标准也在不停的扩展, 最常用的是用两个字节表示一个字符(这个地
方的字符是不区分英文还是中文的), 所以到目前为止, ascii码和unicode编码的区别就是前者采用一个字节编码(其实连一个字节都用不上,总共127个字符, 7个byte正好就够了), 后者用两个字节但是如果你写的文本全是英文的话,
采取unicode编码是不是就有点浪费空间了呢, 对于存储和传输都是十分不利的, 比如字母A在ascii编码中存储的二
进制为01000001, 但是在unicode编码中为 00000000 01000001, 为了解决这种情况, 就出现了一种变长的unicode编码, 被称为 utf-8 编码
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;utf-8编码
    &lt;pre&gt;&lt;code&gt;utf-8规定, 把一个unicode字符编码成1-6个字节, 常用的英文被编码成1个字节(unicode是2个字节), 中文一般
用3个字节(unicode也是2个字节), 只有那些很生僻的汉字才会用到4-6个字节
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;字符&lt;/td&gt;
      &lt;td&gt;ASCII码&lt;/td&gt;
      &lt;td&gt;unicode编码&lt;/td&gt;
      &lt;td&gt;utf-8编码&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;A&lt;/td&gt;
      &lt;td&gt;–01000001–&lt;/td&gt;
      &lt;td&gt;–00000000 01000001–&lt;/td&gt;
      &lt;td&gt;–01000001–&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;中&lt;/td&gt;
      &lt;td&gt;–x–&lt;/td&gt;
      &lt;td&gt;–01001110 00101101–&lt;/td&gt;
      &lt;td&gt;–11100100 10111000 10101101–&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code&gt;另外, 在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件
&lt;/code&gt;&lt;/pre&gt;

</content>
 </entry>
 
 <entry>
   <title>php和java中对aes加密方式的不同</title>
   <link href="http://wanghongjun2014.github.io/posts/php-java-aes.html"/>
   <updated>2017-04-21T00:00:00-07:00</updated>
   <id>/posts/php-java-aes</id>
   <content type="html">&lt;p&gt;周末的时候写了一个联通代扣取话费需求的接口,由于文档中只给出了java aes加密的示例, 加密方式为PKCS5, 但是这种方
式php中是不支持的(我用java的入参调试了n久, 结果都是错的, 坑了很长时间, 翻阅很多文档终于找到了方案), php的解决方案如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; //加密函数
 function encrypt($plaintext, $key) {
     $plaintext = pkcs5_pad($plaintext, 16);
     return bin2hex(mcrypt_encrypt(MCRYPT_RIJNDAEL_128, hex2bin($key), $plaintext, MCRYPT_MODE_ECB));
 }
 
 //解密函数
 function decrypt($encrypted, $key) {
     $decrypted = mcrypt_decrypt(MCRYPT_RIJNDAEL_128, hex2bin($key), hex2bin($encrypted), MCRYPT_MODE_ECB);
     $padSize = ord(substr($decrypted, -1));
     return substr($decrypted, 0, $padSize*-1);
 }
 
 //pad偏移函数
 function pkcs5_pad ($text, $blocksize)
 {
     $pad = $blocksize - (strlen($text) % $blocksize);
     return $text . str_repeat(chr($pad), $pad);
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考文档: &lt;a href=&quot;http://stackoverflow.com/questions/17835726/aes-encryption-using-java-and-php&quot; title=&quot;aes&quot;&gt;http://stackoverflow.com/questions/17835726/aes-encryption-using-java-and-php&lt;/a&gt;&lt;/p&gt;

</content>
 </entry>
 
 
</feed>